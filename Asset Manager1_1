local Tween = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

return function(plugin, button)
	-- [1. SETUP]
	button.Visible = false 

	-- Data Management
	local IndexKey = "OBM_Index_v1"
	local SavedIndex = plugin:GetSetting(IndexKey) or {}
	local SortedKeys = {} 

	local function updateKeys()
		SortedKeys = {}
		for _, name in ipairs(SavedIndex) do table.insert(SortedKeys, name) end
		table.sort(SortedKeys)
	end

	local OldDB = plugin:GetSetting("GameStateSaves")
	if OldDB then
		for name, data in pairs(OldDB) do
			plugin:SetSetting("OBM_Data_"..name, data)
			table.insert(SavedIndex, name)
		end
		plugin:SetSetting(IndexKey, SavedIndex)
		plugin:SetSetting("GameStateSaves", nil)
	end
	updateKeys()

	local currentIndex = 1
	local active = true
	local isInBrowser = false
	local browserTree = nil    
	local browserHistory = {}  
	local currentParentID = 0
	local siblingIndex = 1
	local currentSiblings = {} 

	local function get(name)
		local s, svc = pcall(function() return game:GetService(name) end)
		return (s and svc) or nil
	end

	local TargetServices = {
		workspace, get("Players"), get("Lighting"), get("MaterialService"),
		get("NetworkClient"), get("ReplicatedFirst"), get("ReplicatedStorage"),
		get("ServerScriptService"), get("ServerStorage"), get("StarterGui"),
		get("StarterPack"), get("StarterPlayer"), get("Teams"),
		get("SoundService"), get("TextChatService"), get("Chat")
	}
	for i = #TargetServices, 1, -1 do if not TargetServices[i] then table.remove(TargetServices, i) end end

	local SpecialSingletons = {
		"ChatWindowConfiguration", "ChatInputBarConfiguration",
		"BubbleChatConfiguration", "ChannelTabsConfiguration", "ClientReplicator"
	}

	local TerrainForceProps = {
		"Decoration", "GrassLength", "WaterColor", "WaterReflectance", 
		"WaterTransparency", "WaterWaveSize", "WaterWaveSpeed"
	}

	-- [2. SERIALIZER ENGINE]
	local function Pack(val, objToID)
		local t = typeof(val)
		if t == "string" or t == "number" or t == "boolean" then return val end

		if t == "Instance" then
			if objToID and objToID[val] then return {Type="Ref", ID=objToID[val]}
			else
				local isService, svcName = false, ""
				pcall(function() if val == game.Workspace then isService=true; svcName="Workspace" end end)
				if not isService then pcall(function() if val:IsA("Service") then isService=true; svcName=val.ClassName end end) end
				if isService then return {Type="Svc", Class=svcName} else return nil end
			end
		end

		if t == "Vector3" then return {Type="V3", V={val.X, val.Y, val.Z}}
		elseif t == "Vector2" then return {Type="V2", V={val.X, val.Y}}
		elseif t == "CFrame" then return {Type="CF", V={val:GetComponents()}}
		elseif t == "Color3" then return {Type="C3", V={val.R, val.G, val.B}}
		elseif t == "UDim2" then return {Type="U2", V={val.X.Scale, val.X.Offset, val.Y.Scale, val.Y.Offset}}
		elseif t == "UDim" then return {Type="U1", V={val.Scale, val.Offset}}
		elseif t == "Rect" then return {Type="Rc", V={val.Min.X, val.Min.Y, val.Max.X, val.Max.Y}}
		elseif t == "NumberRange" then return {Type="NR", V={val.Min, val.Max}}
		elseif t == "EnumItem" then return {Type="En", V=tostring(val)} 
		elseif t == "BrickColor" then return {Type="BC", V=val.Name}
		elseif t == "PhysicalProperties" then 
			if val then return {Type="PP", V={val.Density, val.Friction, val.Elasticity, val.FrictionWeight, val.ElasticityWeight}} end
		elseif t == "ColorSequence" then
			local kps = {}
			for _, k in ipairs(val.Keypoints) do table.insert(kps, {T=k.Time, C={k.Value.R, k.Value.G, k.Value.B}}) end
			return {Type="CS", V=kps}
		elseif t == "NumberSequence" then
			local kps = {}
			for _, k in ipairs(val.Keypoints) do table.insert(kps, {T=k.Time, V=k.Value, E=k.Envelope}) end
			return {Type="NS", V=kps}
		elseif t == "Instance" or t == "function" or t == "userdata" then return nil
		else return tostring(val) end
	end

	local function Unpack(data, idToObj)
		if type(data) ~= "table" then return data end
		if not data.Type then return data end

		if data.Type == "Ref" then return idToObj and idToObj[data.ID]
		elseif data.Type == "Svc" then
			if data.Class == "Workspace" then return game.Workspace end
			local s, svc = pcall(function() return game:GetService(data.Class) end)
			return (s and svc) or nil

		elseif data.Type == "V3" then return Vector3.new(unpack(data.V))
		elseif data.Type == "V2" then return Vector2.new(unpack(data.V))
		elseif data.Type == "CF" then return CFrame.new(unpack(data.V))
		elseif data.Type == "C3" then return Color3.new(unpack(data.V))
		elseif data.Type == "U2" then return UDim2.new(unpack(data.V))
		elseif data.Type == "U1" then return UDim.new(unpack(data.V))
		elseif data.Type == "BC" then return BrickColor.new(data.V)
		elseif data.Type == "PP" then return PhysicalProperties.new(unpack(data.V))
		elseif data.Type == "NR" then return NumberRange.new(unpack(data.V))
		elseif data.Type == "Rc" then return Rect.new(unpack(data.V))
		elseif data.Type == "En" then
			local parts = string.split(data.V, ".")
			if #parts >= 3 then 
				local s, e = pcall(function() return Enum[parts[2]][parts[3]] end)
				if s then return e end
			end
			return nil
		elseif data.Type == "CS" then
			local kps = {}
			for _, k in ipairs(data.V) do table.insert(kps, ColorSequenceKeypoint.new(k.T, Color3.new(unpack(k.C)))) end
			return ColorSequence.new(kps)
		elseif data.Type == "NS" then
			local kps = {}
			for _, k in ipairs(data.V) do table.insert(kps, NumberSequenceKeypoint.new(k.T, k.V, k.E or 0)) end
			return NumberSequence.new(kps)
		end
		return data
	end

	-- [API LOOKUP]
	local DefaultsLookup = nil
	local function generateLookup()
		if DefaultsLookup then return DefaultsLookup end

		local s, apiDump = pcall(function()
			local versionUrl = "https://setup.rbxcdn.com/versionQTStudio"
			local versionHash = HttpService:GetAsync(versionUrl)
			local dumpUrl = "https://setup.rbxcdn.com/" .. versionHash .. "-API-Dump.json"
			return HttpService:JSONDecode(HttpService:GetAsync(dumpUrl))
		end)
		if not s or not apiDump then return {} end

		local classDefs = {}
		for _, def in pairs(apiDump.Classes) do classDefs[def.Name] = def end

		local function getPropNames(className)
			local props = {}
			local current = className
			while current do
				local def = classDefs[current]
				if def then
					for _, m in pairs(def.Members) do
						if m.MemberType == "Property" then
							local isReadOnly = false
							if m.Tags then for _, t in pairs(m.Tags) do if t=="ReadOnly" then isReadOnly=true end end end
							if not isReadOnly and m.Name ~= "Parent" then table.insert(props, m.Name) end
						end
					end
					current = def.Superclass
				else break end
			end
			return props
		end

		local output = {}
		local singletonMap = {}
		for _, svc in ipairs(TargetServices) do singletonMap[svc.ClassName] = true end
		singletonMap["Terrain"] = true
		for _, name in ipairs(SpecialSingletons) do singletonMap[name] = true end

		for className, def in pairs(classDefs) do
			local isSingleton = singletonMap[className]
			if isSingleton then
				local props = getPropNames(className)
				if className == "Terrain" then
					for _, p in ipairs(TerrainForceProps) do
						local found = false
						for _, existing in ipairs(props) do if existing == p then found = true break end end
						if not found then table.insert(props, p) end
					end
				end
				output[className] = { Props = props, Values = nil }
			else
				local instance, temp = nil, false
				local isCreatable = true
				if def.Tags then for _, t in pairs(def.Tags) do if t=="NotCreatable" or t=="Settings" or t=="Service" then isCreatable=false end end end

				if isCreatable then
					local s, newObj = pcall(function() return Instance.new(className) end)
					if s and newObj then instance = newObj; temp = true end
				end

				if instance then
					local props = getPropNames(className)
					if #props > 0 then
						output[className] = { Props = props, Values = nil }
						if temp then
							local vals = {}
							for _, pName in ipairs(props) do
								local vs, v = pcall(function() return instance[pName] end)
								if vs then vals[pName] = v end
							end
							output[className].Values = vals
							instance:Destroy()
						end
					end
				end
			end
		end
		DefaultsLookup = output
		return output
	end

	-- [TERRAIN EXTRAS]
	local function SaveTerrainExtras(terrain)
		local extras = {}
		local matColors = {}
		local materials = Enum.Material:GetEnumItems()
		for _, mat in ipairs(materials) do
			local s, col = pcall(function() return terrain:GetMaterialColor(mat) end)
			if s and col then matColors[mat.Name] = Pack(col) end
		end
		extras.MatColors = matColors
		local regionSize = 512 
		local region = Region3.new(Vector3.new(-regionSize, -256, -regionSize), Vector3.new(regionSize, 256, regionSize))
		local s, mats, occs = pcall(function() return terrain:ReadVoxels(region, 4) end)
		if s and mats then
			local rleM, rleO = {}, {}
			local size = mats.Size
			local lastM, countM = nil, 0
			local lastO, countO = nil, 0
			for x = 1, size.X do
				for y = 1, size.Y do
					for z = 1, size.Z do
						local m = mats[x][y][z].Name
						local o = occs[x][y][z]
						if m == lastM then countM = countM + 1
						else if lastM then table.insert(rleM, lastM); table.insert(rleM, countM) end lastM = m; countM = 1 end
						if o == lastO then countO = countO + 1
						else if lastO then table.insert(rleO, lastO); table.insert(rleO, countO) end lastO = o; countO = 1 end
					end
				end
			end
			if lastM then table.insert(rleM, lastM); table.insert(rleM, countM) end
			if lastO then table.insert(rleO, lastO); table.insert(rleO, countO) end
			extras.Voxels = {M=rleM, O=rleO, Size={size.X, size.Y, size.Z}}
		end
		return extras
	end

	local function LoadTerrainExtras(terrain, extras)
		if not extras then return end
		if extras.MatColors then
			for name, colData in pairs(extras.MatColors) do
				local col = Unpack(colData)
				local s, mat = pcall(function() return Enum.Material[name] end)
				if s and mat and col then pcall(function() terrain:SetMaterialColor(mat, col) end) end
			end
		end
		if extras.Voxels then
			local v = extras.Voxels
			local sizeX, sizeY, sizeZ = v.Size[1], v.Size[2], v.Size[3]
			local regionSize = 512
			local region = Region3.new(Vector3.new(-regionSize, -256, -regionSize), Vector3.new(regionSize, 256, regionSize))
			local rawM = table.create(sizeX)
			local rawO = table.create(sizeX)
			local ptrM, ptrO = 1, 1
			local valM, remM = v.M[1], v.M[2]
			local valO, remO = v.O[1], v.O[2]
			for x = 1, sizeX do
				rawM[x], rawO[x] = table.create(sizeY), table.create(sizeY)
				for y = 1, sizeY do
					rawM[x][y], rawO[x][y] = table.create(sizeZ), table.create(sizeZ)
					for z = 1, sizeZ do
						if remM <= 0 then ptrM = ptrM + 2; valM, remM = v.M[ptrM], v.M[ptrM+1] end
						rawM[x][y][z] = Enum.Material[valM or "Air"]
						remM = remM - 1
						if remO <= 0 then ptrO = ptrO + 2; valO, remO = v.O[ptrO], v.O[ptrO+1] end
						rawO[x][y][z] = valO or 0
						remO = remO - 1
					end
				end
			end
			pcall(function() terrain:WriteVoxels(region, 4, rawM, rawO) end)
		end
	end

	-- [3. SAVE STATE]
	local function SaveState(name, roots, mode)
		local Defaults = generateLookup()
		local objToID, nextID, dataList = {}, 1, {}
		local function mapIDs(obj)
			objToID[obj] = nextID; nextID = nextID + 1 
			for _, child in ipairs(obj:GetChildren()) do mapIDs(child) end
		end
		for _, root in ipairs(roots) do mapIDs(root) end
		for _, root in ipairs(roots) do
			local descendants = root:GetDescendants()
			table.insert(descendants, 1, root)
			for _, obj in ipairs(descendants) do
				local id = objToID[obj]
				local classInfo = Defaults[obj.ClassName]
				if obj.ClassName == "Terrain" and not classInfo then classInfo = { Props = TerrainForceProps, Values = nil } end
				if id and classInfo then
					local props = {}
					for _, prop in ipairs(classInfo.Props) do
						local success, val = pcall(function() return obj[prop] end)
						if success then
							local save = false
							if classInfo.Values then
								if val ~= classInfo.Values[prop] then save = true end
							else save = true end
							if save then 
								local packed = Pack(val, objToID)
								if packed ~= nil then props[prop] = packed end
							end
						end
					end
					local extraData = nil
					if obj.ClassName == "Terrain" then extraData = SaveTerrainExtras(obj) end
					local parentID = (obj.Parent and objToID[obj.Parent]) or 0
					table.insert(dataList, {I=id, C=obj.ClassName, P=parentID, D=props, X=extraData})
				end
			end
		end

		local finalData = {Data = dataList, Mode = mode}
		local success, err = pcall(function() plugin:SetSetting("OBM_Data_"..name, finalData) end)
		if success then
			local exists = false
			for _, n in ipairs(SavedIndex) do if n == name then exists = true break end end
			if not exists then table.insert(SavedIndex, name) end
			plugin:SetSetting(IndexKey, SavedIndex)
			updateKeys()
			for i, k in ipairs(SortedKeys) do if k == name then currentIndex = i break end end
		else warn("OBM: Save Failed (Too Large)") end
	end

	-- [POOL RESOLVER - THE FIX]
	-- objectPool: { [ParentInstance] = { ["Part"] = {Obj1, Obj2}, ["Script"] = {Obj3} } }
	local function ResolveObject(node, parentObj, objectPool)
		-- 1. Global Singletons
		if node.C == "Workspace" then return game.Workspace end
		if node.C == "Terrain" then return game.Workspace.Terrain end
		local isService, svc = pcall(function() return game:GetService(node.C) end)
		if isService and svc then return svc end

		-- 2. Child Resolving (With Pool)
		if parentObj then
			-- A. Lazily populate pool for this parent if needed
			if not objectPool[parentObj] then
				objectPool[parentObj] = {}
				for _, child in ipairs(parentObj:GetChildren()) do
					if not objectPool[parentObj][child.ClassName] then
						objectPool[parentObj][child.ClassName] = {}
					end
					table.insert(objectPool[parentObj][child.ClassName], child)
				end
			end

			-- B. Try to claim an existing object from the pool
			local available = objectPool[parentObj][node.C]
			if available and #available > 0 then
				return table.remove(available, 1) -- Return and remove so it isn't used again
			end
		end

		-- 3. Create New
		local s, newObj = pcall(function() return Instance.new(node.C) end)
		if s then return newObj end
		return nil
	end

	local function ApplyProperties(obj, props, idToObj)
		local keys = {} for k in pairs(props) do table.insert(keys, k) end table.sort(keys)
		for _, k in ipairs(keys) do pcall(function() obj[k] = Unpack(props[k], idToObj) end) end
	end

	local function LoadBranch(node, data, targetParent, shallow)
		if not node then return end
		local idToObj, idsToLoad = {}, {}
		local objectPool = {} -- Instance Pool per load operation

		if shallow then idsToLoad[node.I] = true
		else
			idsToLoad[node.I] = true
			local function findKids(pid)
				for _, n in ipairs(data) do if n.P == pid then idsToLoad[n.I] = true; findKids(n.I) end end
			end
			findKids(node.I)
		end
		for _, n in ipairs(data) do
			if idsToLoad[n.I] then
				local parentObj = (n.P > 0 and idToObj[n.P]) or nil
				local obj = ResolveObject(n, parentObj, objectPool) -- Pass Pool
				if obj then
					idToObj[n.I] = obj
					if n.X and obj:IsA("Terrain") then LoadTerrainExtras(obj, n.X) end
					if not obj:IsA("Service") and obj.Name ~= "Workspace" and obj.ClassName ~= "Terrain" then
						local isChildSingleton = obj.ClassName:match("Configuration") and obj.Parent and obj.Parent:IsA("TextChatService")
						if not isChildSingleton then
							local parent = idToObj[n.P]
							if parent then pcall(function() obj.Parent = parent end)
							else pcall(function() obj.Parent = targetParent end) end
						end
					end
				end
			end
		end
		for _, n in ipairs(data) do if idsToLoad[n.I] and idToObj[n.I] then ApplyProperties(idToObj[n.I], n.D, idToObj) end end
	end

	local function LoadFullState(name, targetParent)
		local entry = plugin:GetSetting("OBM_Data_"..name)
		if not entry then return end
		local data = entry.Data
		local idToObj = {}
		local objectPool = {} -- Instance Pool per load operation

		for _, node in ipairs(data) do
			local parentObj = (node.P > 0) and idToObj[node.P] or nil
			local obj = ResolveObject(node, parentObj, objectPool) -- Pass Pool
			if obj then
				idToObj[node.I] = obj
				if node.X and obj:IsA("Terrain") then LoadTerrainExtras(obj, node.X) end
				if not obj:IsA("Service") and obj.Name ~= "Workspace" and obj.ClassName ~= "Terrain" then
					local isChildSingleton = obj.ClassName:match("Configuration") and obj.Parent and obj.Parent:IsA("TextChatService")
					if not isChildSingleton then
						local parent = idToObj[node.P]
						if parent then pcall(function() obj.Parent = parent end)
						elseif entry.Mode == "Snippet" then pcall(function() obj.Parent = targetParent end) end
					end
				end
			end
		end
		for _, node in ipairs(data) do if idToObj[node.I] then ApplyProperties(idToObj[node.I], node.D, idToObj) end end
	end

	-- [5. BROWSER ENGINE]
	local function BuildTree(saveData)
		local tree, roots = {}, {}
		for _, node in ipairs(saveData) do tree[node.I] = { Node = node, Children = {} } end
		for _, node in ipairs(saveData) do if node.P == 0 then table.insert(roots, node) elseif tree[node.P] then table.insert(tree[node.P].Children, node) end end
		local function sortNodes(a,b) local na = (a.D and a.D.Name) and Unpack(a.D.Name) or a.C local nb = (b.D and b.D.Name) and Unpack(b.D.Name) or b.C return na < nb end
		table.sort(roots, sortNodes) for _, t in pairs(tree) do table.sort(t.Children, sortNodes) end return tree, roots
	end

	-- [6. UI CONSTRUCTION]
	local Overlay = Instance.new("Frame", button.Parent) Overlay.Name, Overlay.Size, Overlay.Position, Overlay.BackgroundColor3, Overlay.BorderColor3, Overlay.BorderSizePixel, Overlay.ClipsDescendants, Overlay.ZIndex = "BrowserOverlay", UDim2.new(1, 0, 0, 30), button.Position, Color3.fromRGB(30, 30, 30), Color3.fromRGB(255, 150, 0), 1, true, 105
	local DisplayFrame = Instance.new("TextButton", Overlay) DisplayFrame.Size, DisplayFrame.Position, DisplayFrame.BackgroundTransparency, DisplayFrame.Text, DisplayFrame.ZIndex = UDim2.new(0.4, 0, 1, 0), UDim2.new(0.2, 0, 0, 0), 1, "", 106
	local function createLabel(text, xPos, color) local lbl = Instance.new("TextLabel", DisplayFrame) lbl.Size, lbl.Position, lbl.BackgroundTransparency, lbl.TextColor3, lbl.Font, lbl.TextSize, lbl.Text, lbl.ZIndex = UDim2.new(1,0,1,0), UDim2.new(xPos, 0, 0, 0), 1, color or Color3.new(1,1,1), Enum.Font.Code, 11, text, 106 return lbl end
	local currentLabel = createLabel("Loading...", 0)
	local function makeBtn(text, xScale, widthScale) local b = Instance.new("TextButton", Overlay) b.Text, b.Size, b.Position, b.BackgroundColor3, b.TextColor3, b.BorderSizePixel, b.ZIndex = text, UDim2.new(widthScale, 0, 1, 0), UDim2.new(xScale, 0, 0, 0), Color3.fromRGB(40,40,40), Color3.new(1,1,1), 0, 107 return b end
	local btnPrev, btnNext, btnSave, btnExit = makeBtn("<", 0, 0.2), makeBtn(">", 0.6, 0.2), makeBtn("ðŸ’¾", 0.8, 0.1), makeBtn("X", 0.9, 0.1)
	btnSave.BackgroundColor3, btnSave.TextColor3, btnExit.BackgroundColor3 = Color3.fromRGB(50,50,50), Color3.fromRGB(0, 170, 255), Color3.fromRGB(150, 40, 40)
	local AddInput = Instance.new("TextBox", Overlay) AddInput.Size, AddInput.Position, AddInput.BackgroundTransparency, AddInput.Text, AddInput.PlaceholderText, AddInput.TextColor3, AddInput.TextTransparency, AddInput.ZIndex, AddInput.Visible = UDim2.new(0.4, 0, 1, 0), UDim2.new(0.2, 0, 0, 0), 1, "", "", Color3.new(1,1,1), 1, 110, false

	local confirmWipe = false
	btnExit.MouseButton1Click:Connect(function() confirmWipe = false btnExit.Text="X" btnExit.BackgroundColor3 = Color3.fromRGB(150, 40, 40) Overlay:Destroy() button.Visible = true end)
	btnExit.MouseButton2Click:Connect(function()
		if not confirmWipe then
			confirmWipe = true; btnExit.Text = "WIPE?"; btnExit.BackgroundColor3 = Color3.fromRGB(255, 0, 0); currentLabel.Text = "RIGHT CLICK TO WIPE"; currentLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
		else
			currentLabel.Text = "WIPING..."
			task.wait(0.1)
			local list = plugin:GetSetting(IndexKey) or {}
			for _, key in ipairs(list) do plugin:SetSetting("OBM_Data_"..key, nil) end
			plugin:SetSetting(IndexKey, nil)
			plugin:SetSetting("GameStateSaves", nil)
			SavedIndex = {}; SortedKeys = {}; currentIndex = 1
			currentLabel.Text = "WIPED!"; currentLabel.TextColor3 = Color3.fromRGB(0, 255, 0); task.wait(1)
			confirmWipe = false; btnExit.Text = "X"; btnExit.BackgroundColor3 = Color3.fromRGB(150, 40, 40); Overlay:Destroy(); button.Visible = true
		end
	end)

	local function refreshBrowserSiblings()
		local entry = plugin:GetSetting("OBM_Data_"..SortedKeys[currentIndex])
		if not entry then return end
		if currentParentID == 0 then local _, roots = BuildTree(entry.Data) currentSiblings = roots
		else if browserTree[currentParentID] then currentSiblings = browserTree[currentParentID].Children else currentSiblings = {} end end
		if siblingIndex > #currentSiblings then siblingIndex = 1 end if siblingIndex < 1 then siblingIndex = 1 end
	end

	local function updateDisplay(direction, statusOverride)
		local text, color = "", Color3.new(1,1,1)
		if isInBrowser then
			btnPrev.Text, btnNext.Visible = "â¬†", false
			if #currentSiblings > 0 then
				local node = currentSiblings[siblingIndex]
				local name = node.C
				if node.D and node.D.Name then name = Unpack(node.D.Name) end
				local hasKids = false
				if browserTree[node.I] and #browserTree[node.I].Children > 0 then hasKids = true end
				text, color = (hasKids and "ðŸ“‚ " or "ðŸ”¹ ")..name, Color3.fromRGB(255, 200, 100)
			else text = "(Empty)" end
		else
			btnPrev.Text, btnNext.Visible, btnNext.Text = "<", true, ">"
			local key = SortedKeys[currentIndex]
			text = key and "ðŸ“¦ "..key or "(Empty)"
			if key then local entry = plugin:GetSetting("OBM_Data_"..key) if entry then text = (entry.Mode=="GameState" and "ðŸŒ " or "ðŸ“„ ")..key end end
		end
		if statusOverride then text, color = statusOverride, Color3.fromRGB(0,255,0) end
		if direction == 0 then currentLabel.Text, currentLabel.TextColor3 = text, color
		else
			local newLbl = createLabel(text, (direction == 1) and 1 or -1, color)
			Tween:Create(newLbl, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0,0,0,0)}):Play()
			local out = Tween:Create(currentLabel, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new((direction == 1) and -1 or 1,0,0,0)})
			out:Play() out.Completed:Connect(function() out:Destroy() end) currentLabel = newLbl
		end
	end

	DisplayFrame.InputBegan:Connect(function(input)
		local key = SortedKeys[currentIndex] if not key then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			local sel, target = game.Selection:Get(), game.Selection:Get()[1] or workspace
			updateDisplay(0, "LOADING...") task.wait(0.1)
			if isInBrowser then if #currentSiblings > 0 then local entry = plugin:GetSetting("OBM_Data_"..key) LoadBranch(currentSiblings[siblingIndex], entry.Data, target, false) end
			else LoadFullState(key, target) end updateDisplay(0, "LOADED!") task.wait(0.5) updateDisplay(0)
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			if isInBrowser then
				if #currentSiblings > 0 then local node = currentSiblings[siblingIndex] if browserTree[node.I] and #browserTree[node.I].Children > 0 then table.insert(browserHistory, currentParentID) currentParentID = node.I siblingIndex = 1 refreshBrowserSiblings() updateDisplay(1) else updateDisplay(0, "End of Branch") task.wait(0.5) updateDisplay(0) end end
			else
				updateDisplay(0, "OPENING...") task.wait(0.1) local entry = plugin:GetSetting("OBM_Data_"..key) if entry then local tree, roots = BuildTree(entry.Data) browserTree = tree currentParentID = 0 browserHistory = {} siblingIndex = 1 isInBrowser = true refreshBrowserSiblings() updateDisplay(0) end
			end
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			if isInBrowser then if #currentSiblings > 0 then local entry = plugin:GetSetting("OBM_Data_"..key) LoadBranch(currentSiblings[siblingIndex], entry.Data, game.Selection:Get()[1] or workspace, true) updateDisplay(0, "SPAWNED!") task.wait(0.5) updateDisplay(0) end
			else plugin:SetSetting("OBM_Data_"..key, nil) for i, n in ipairs(SavedIndex) do if n == key then table.remove(SavedIndex, i) break end end plugin:SetSetting(IndexKey, SavedIndex) updateKeys() if currentIndex > #SortedKeys then currentIndex = math.max(1, #SortedKeys) end updateDisplay(0, "DELETED") task.wait(0.5) updateDisplay(0) end
		end
	end)

	btnPrev.MouseButton1Click:Connect(function() if isInBrowser then if currentParentID == 0 then isInBrowser = false browserTree = nil updateDisplay(-1) else currentParentID = table.remove(browserHistory) or 0 siblingIndex = 1 refreshBrowserSiblings() updateDisplay(-1) end else currentIndex = currentIndex - 1 if currentIndex < 1 then currentIndex = #SortedKeys end if #SortedKeys == 0 then currentIndex = 1 end updateDisplay(-1) end end)
	btnNext.MouseButton1Click:Connect(function() if not isInBrowser then currentIndex = currentIndex + 1 if currentIndex > #SortedKeys then currentIndex = 1 end updateDisplay(1) end end)
	DisplayFrame.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseWheel then if isInBrowser then if #currentSiblings > 0 then local delta = (input.Position.Z > 0) and -1 or 1 siblingIndex = siblingIndex + delta if siblingIndex < 1 then siblingIndex = #currentSiblings end if siblingIndex > #currentSiblings then siblingIndex = 1 end updateDisplay(0) end else if #SortedKeys > 0 then local delta = (input.Position.Z > 0) and -1 or 1 currentIndex = currentIndex + delta if currentIndex < 1 then currentIndex = #SortedKeys end if currentIndex > #SortedKeys then currentIndex = 1 end updateDisplay(0) end end end end)
	btnSave.MouseButton1Click:Connect(function() if not AddInput.Visible then AddInput.Visible = true AddInput.BackgroundTransparency = 0.2 AddInput.BackgroundColor3 = Color3.new(0,0,0) AddInput.TextTransparency = 0 AddInput.PlaceholderText = "Save Name..." currentLabel.Visible = false AddInput:CaptureFocus() else AddInput.Text = "" AddInput:ReleaseFocus() end end)
	AddInput.FocusLost:Connect(function(enter) AddInput.Visible = false AddInput.BackgroundTransparency = 1 AddInput.TextTransparency = 1 currentLabel.Visible = true if enter and AddInput.Text ~= "" then local name = AddInput.Text local sel = game.Selection:Get() updateDisplay(0, "SAVING...") task.wait(0.1) if #sel > 0 then SaveState(name, sel, "Snippet") else SaveState(name, TargetServices, "GameState") end updateDisplay(0, "SAVED!") task.wait(0.8) updateDisplay(0) end AddInput.Text = "" end)

	if #SortedKeys > 0 then updateDisplay(0) else updateDisplay(0, "(No Saves)") end
end
